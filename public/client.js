/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./app/client.ts":
/*!***********************!*\
  !*** ./app/client.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n\n\n\n\n\n\n\n\nfunction initializeGame(state) {\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_6__.bindMouseListeners)();\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_6__.addContextMenuListeners)();\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__.addKeyboardListeners)();\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_4__.query)('.js-loading').style.display = 'none';\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_4__.query)('.js-gameContent').style.display = '';\n    state.gameHasBeenInitialized = true;\n    state.spaceship.x = app_utils_canvas__WEBPACK_IMPORTED_MODULE_2__.mainCanvas.width / 2;\n    state.spaceship.y = app_utils_canvas__WEBPACK_IMPORTED_MODULE_2__.mainCanvas.height / 2;\n}\nfunction update() {\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_1__.getState)();\n    if (!state.gameHasBeenInitialized) {\n        initializeGame(state);\n    }\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__.updateKeyboardState)(state);\n    updatePlayerSpaceship(state);\n    updateBullets(state);\n    updateAsteroids(state);\n    state.camera.x = state.spaceship.x - app_utils_canvas__WEBPACK_IMPORTED_MODULE_2__.mainCanvas.width / 2;\n    state.camera.y = state.spaceship.y - app_utils_canvas__WEBPACK_IMPORTED_MODULE_2__.mainCanvas.height / 2;\n}\nfunction updateBullets(state) {\n    for (let i = 0; i < state.playerBullets.length; i++) {\n        const bullet = state.playerBullets[i];\n        bullet.x += bullet.velocity.x;\n        bullet.y += bullet.velocity.y;\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getDistance)(state.spaceship, bullet) > app_constants__WEBPACK_IMPORTED_MODULE_7__.BULLET_CULLING_DISTANCE) {\n            state.playerBullets.splice(i--, 1);\n            return;\n        }\n    }\n}\nfunction updateAsteroids(state) {\n    for (let i = 0; i < state.asteroids.length; i++) {\n        const asteroid = state.asteroids[i];\n        asteroid.x += asteroid.velocity.x;\n        asteroid.y += asteroid.velocity.y;\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getDistance)(state.spaceship, asteroid) > app_constants__WEBPACK_IMPORTED_MODULE_7__.ASTEROID_CULLING_DISTANCE) {\n            state.asteroids.splice(i--, 1);\n            return;\n        }\n    }\n    while (state.asteroids.length < 5) {\n        state.asteroids.push(createAsteroid(state));\n    }\n}\nfunction updatePlayerSpaceship(state) {\n    const spaceship = state.spaceship;\n    let acceleration = 0;\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_7__.GAME_KEY.UP)) {\n        acceleration = .15;\n    }\n    else if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_7__.GAME_KEY.DOWN)) {\n        acceleration = -0.05;\n    }\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_7__.GAME_KEY.LEFT)) {\n        spaceship.rotation -= 0.1;\n    }\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_7__.GAME_KEY.RIGHT)) {\n        spaceship.rotation += 0.1;\n    }\n    const dx = Math.cos(spaceship.rotation), dy = Math.sin(spaceship.rotation);\n    spaceship.velocity.x += acceleration * dx;\n    spaceship.velocity.y += acceleration * dy;\n    // Add some friction to slow the ship down a bit.\n    spaceship.velocity.x *= 0.98;\n    spaceship.velocity.y *= 0.98;\n    spaceship.x += spaceship.velocity.x;\n    spaceship.y += spaceship.velocity.y;\n    if (spaceship.shootCooldown > 0) {\n        spaceship.shootCooldown -= app_constants__WEBPACK_IMPORTED_MODULE_7__.FRAME_LENGTH;\n    }\n    if (spaceship.shootCooldown <= 0 && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_7__.GAME_KEY.SHOOT)) {\n        state.playerBullets.push({\n            x: spaceship.x + spaceship.size * dx,\n            y: spaceship.y + spaceship.size * dy,\n            velocity: {\n                x: dx * 5 + spaceship.velocity.x,\n                y: dy * 5 + spaceship.velocity.y,\n            },\n            size: 3,\n            rotation: spaceship.rotation,\n        });\n        spaceship.shootCooldown = spaceship.reloadTime;\n    }\n}\nfunction createAsteroid(state) {\n    const spawnAngle = 2 * Math.PI * Math.random();\n    const rotation = 2 * Math.PI * Math.random();\n    const distance = app_constants__WEBPACK_IMPORTED_MODULE_7__.ASTEROID_GENERATION_DISTANCE_RANGE[0] + Math.random() * (app_constants__WEBPACK_IMPORTED_MODULE_7__.ASTEROID_GENERATION_DISTANCE_RANGE[1] - app_constants__WEBPACK_IMPORTED_MODULE_7__.ASTEROID_GENERATION_DISTANCE_RANGE[0]);\n    return {\n        x: state.spaceship.x + distance * Math.cos(spawnAngle),\n        y: state.spaceship.y + distance * Math.sin(spawnAngle),\n        velocity: {\n            x: 2 * Math.cos(rotation),\n            y: 2 * Math.sin(rotation),\n        },\n        size: 15,\n        rotation,\n    };\n}\nfunction renderLoop() {\n    try {\n        window.requestAnimationFrame(renderLoop);\n        const state = (0,app_state__WEBPACK_IMPORTED_MODULE_1__.getState)();\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__.render)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_2__.mainContext, state);\n    }\n    catch (e) {\n        console.log(e);\n        debugger;\n    }\n}\nrenderLoop();\nsetInterval(update, app_constants__WEBPACK_IMPORTED_MODULE_7__.FRAME_LENGTH);\n\n\n//# sourceURL=webpack://alttp/./app/client.ts?");

/***/ }),

/***/ "./app/constants.ts":
/*!**************************!*\
  !*** ./app/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASTEROID_CULLING_DISTANCE: () => (/* binding */ ASTEROID_CULLING_DISTANCE),\n/* harmony export */   ASTEROID_GENERATION_DISTANCE_RANGE: () => (/* binding */ ASTEROID_GENERATION_DISTANCE_RANGE),\n/* harmony export */   BULLET_CULLING_DISTANCE: () => (/* binding */ BULLET_CULLING_DISTANCE),\n/* harmony export */   FRAME_LENGTH: () => (/* binding */ FRAME_LENGTH),\n/* harmony export */   GAME_KEY: () => (/* binding */ GAME_KEY),\n/* harmony export */   PLAYER_BULLET_SPEED: () => (/* binding */ PLAYER_BULLET_SPEED),\n/* harmony export */   PLAYER_MAX_BULLET_COUNT: () => (/* binding */ PLAYER_MAX_BULLET_COUNT)\n/* harmony export */ });\nconst FRAME_LENGTH = 20;\nconst BULLET_CULLING_DISTANCE = 500;\nconst ASTEROID_CULLING_DISTANCE = 600;\nconst ASTEROID_GENERATION_DISTANCE_RANGE = [520, 550];\nconst PLAYER_BULLET_SPEED = 8;\nconst PLAYER_MAX_BULLET_COUNT = 5;\nconst GAME_KEY = {\n    MENU: 0,\n    UP: 1,\n    DOWN: 2,\n    LEFT: 3,\n    RIGHT: 4,\n    RUN: 5,\n    ACTIVATE: 6,\n    SELL: 7,\n    POTION: 8,\n    AIM_UP: 9,\n    AIM_DOWN: 10,\n    AIM_LEFT: 11,\n    AIM_RIGHT: 12,\n    SHOOT: 13,\n    SPECIAL_ATTACK: 14,\n    MUTE: 15,\n    GUARD_SKILL: 16,\n};\n\n\n//# sourceURL=webpack://alttp/./app/constants.ts?");

/***/ }),

/***/ "./app/render/renderGame.ts":
/*!**********************************!*\
  !*** ./app/render/renderGame.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   render: () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n\nfunction render(context, state) {\n    context.fillStyle = 'black';\n    context.fillRect(0, 0, app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__.mainCanvas.width, app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__.mainCanvas.height);\n    context.save();\n    context.translate(-state.camera.x, -state.camera.y);\n    for (const planet of state.planets) {\n        renderPlanet(context, state, planet);\n        renderGuidanceArrow(context, state, state.spaceship, planet, 'green');\n    }\n    for (const bullet of state.playerBullets) {\n        renderBullet(context, state, bullet);\n    }\n    for (const asteroid of state.asteroids) {\n        renderAsteroid(context, state, asteroid);\n    }\n    renderSpaceship(context, state, state.spaceship);\n    context.restore();\n}\nfunction renderSpaceship(context, state, ship) {\n    var _a;\n    context.save();\n    context.translate(ship.x, ship.y);\n    context.rotate((_a = ship.rotation) !== null && _a !== void 0 ? _a : 0);\n    context.beginPath();\n    context.moveTo(ship.size / 2, 0);\n    context.lineTo(-ship.size / 2, ship.size / 2);\n    context.lineTo(-ship.size / 2, -ship.size / 2);\n    context.closePath();\n    context.strokeStyle = '#fff';\n    context.stroke();\n    context.restore();\n}\nfunction renderPlanet(context, state, planet) {\n    var _a, _b;\n    context.save();\n    // circle\n    context.beginPath();\n    context.arc(planet.x, planet.y, planet.size, 0, 2 * Math.PI);\n    context.strokeStyle = (_a = planet.primaryColor) !== null && _a !== void 0 ? _a : 'white';\n    context.stroke();\n    // squiggle\n    context.beginPath();\n    context.moveTo(planet.x + (2 * planet.size / 7), planet.y + (7 * planet.size / 8));\n    context.bezierCurveTo(planet.x - (planet.size / 2), planet.y + (planet.size / 2), planet.x - (planet.size), planet.y - (planet.size), planet.x - (planet.size / 2), planet.y - (planet.size / 2));\n    context.moveTo(planet.x - (planet.size / 2), planet.y - (planet.size / 2));\n    context.bezierCurveTo(planet.x + (planet.size), planet.y + (planet.size), planet.x + (planet.size / 2), planet.y + (planet.size), planet.x + (planet.size / 2), planet.y - (planet.size / 2));\n    context.strokeStyle = (_b = planet.secondaryColor) !== null && _b !== void 0 ? _b : 'white';\n    context.stroke();\n    context.restore();\n}\nfunction renderBullet(context, state, bullet) {\n    var _a;\n    context.beginPath();\n    context.arc(bullet.x, bullet.y, bullet.size, 0, 2 * Math.PI);\n    context.fillStyle = (_a = bullet.primaryColor) !== null && _a !== void 0 ? _a : 'white';\n    context.fill();\n}\nfunction renderAsteroid(context, state, asteroid) {\n    context.beginPath();\n    context.arc(asteroid.x, asteroid.y, asteroid.size, 0, 2 * Math.PI);\n    context.strokeStyle = '#fff';\n    context.stroke();\n}\nfunction renderGuidanceArrow(context, state, source, target, color) {\n    // Calculate angle and distance to the target\n    const dy = target.y - source.y, dx = target.x - source.x;\n    const distanceToTarget = Math.sqrt(dx * dx + dy * dy);\n    // Only render the arrow if the target is far away.\n    if (distanceToTarget < 300) {\n        return;\n    }\n    const nx = dx / distanceToTarget, ny = dy / distanceToTarget;\n    const triangleX = source.x + 290 * nx;\n    const triangleY = source.y + 290 * ny;\n    context.save();\n    context.beginPath();\n    context.translate(triangleX, triangleY);\n    context.rotate(Math.atan2(ny, nx));\n    context.moveTo(10, 0);\n    context.lineTo(-10, -5);\n    context.lineTo(-10, 5);\n    context.fillStyle = color;\n    context.fill();\n    context.restore();\n}\n\n\n//# sourceURL=webpack://alttp/./app/render/renderGame.ts?");

/***/ }),

/***/ "./app/state.ts":
/*!**********************!*\
  !*** ./app/state.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getState: () => (/* binding */ getState)\n/* harmony export */ });\nconst state = getInitialState();\n// @ts-ignore\nwindow['state'] = state;\nfunction getInitialState() {\n    return {\n        gameHasBeenInitialized: false,\n        mouse: {\n            x: 400,\n            y: 300,\n            isDown: false,\n            wasPressed: false,\n            isRightDown: false,\n            wasRightPressed: false,\n        },\n        isUsingKeyboard: true,\n        keyboard: {\n            gameKeyValues: [],\n            gameKeysDown: new Set(),\n            gameKeysPressed: new Set(),\n            mostRecentKeysPressed: new Set(),\n            gameKeysReleased: new Set(),\n        },\n        audio: {\n            playingTracks: [],\n        },\n        camera: { x: 0, y: 0, },\n        spaceship: {\n            x: 0,\n            y: 0,\n            size: 20,\n            velocity: { x: 0, y: 0 },\n            rotation: -1.5,\n            reloadTime: 200,\n            shootCooldown: 0,\n        },\n        playerBullets: [],\n        planets: [{\n                x: 200,\n                y: 200,\n                velocity: { x: 0, y: 0 },\n                size: 50,\n                primaryColor: 'aqua',\n                secondaryColor: 'lime',\n            }],\n        asteroids: [],\n    };\n}\nfunction getState() {\n    return state;\n}\n\n\n//# sourceURL=webpack://alttp/./app/state.ts?");

/***/ }),

/***/ "./app/utils/canvas.ts":
/*!*****************************!*\
  !*** ./app/utils/canvas.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCanvas: () => (/* binding */ createCanvas),\n/* harmony export */   createCanvasAndContext: () => (/* binding */ createCanvasAndContext),\n/* harmony export */   drawCanvas: () => (/* binding */ drawCanvas),\n/* harmony export */   mainCanvas: () => (/* binding */ mainCanvas),\n/* harmony export */   mainContext: () => (/* binding */ mainContext),\n/* harmony export */   require2dContext: () => (/* binding */ require2dContext)\n/* harmony export */ });\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n\nconst mainCanvas = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-mainCanvas');\n// @ts-ignore\nwindow['mainCanvas'] = mainCanvas;\n// mainCanvas.width = mainCanvas.height = 512;\nconst mainContext = require2dContext(mainCanvas);\n// mainContext.imageSmoothingEnabled = false;\n// @ts-ignore\nwindow['mainContext'] = mainContext;\nfunction require2dContext(canvas) {\n    const context = canvas.getContext('2d');\n    if (!context) {\n        throw new Error('Failed to get context');\n    }\n    return context;\n}\nfunction createCanvas(width, height, classes = '') {\n    const canvas = document.createElement('canvas');\n    canvas.className = classes;\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nfunction createCanvasAndContext(width, height) {\n    const canvas = createCanvas(width, height);\n    const context = require2dContext(canvas);\n    return [canvas, context];\n}\n/**\n * Safari (and possibly other browsers) will not draw canvases if the source\n * rectangle has any parts outside the dimensions of the actual canvas, so this\n * method takes arbitrary rectangles and then modifies them to only draw the\n * part that overlaps with the canvas.\n */\nfunction drawCanvas(context, canvas, { x, y, w, h }, { x: tx, y: ty, w: tw, h: th }) {\n    if (w > canvas.width - x) {\n        const dx = w - (canvas.width - x);\n        w += dx;\n        tw += dx;\n    }\n    if (h > canvas.height - y) {\n        const dy = h - (canvas.height - y);\n        h += dy;\n        th += dy;\n    }\n    if (x < 0) {\n        tx -= x;\n        tw += x;\n        w += x;\n        x = 0;\n    }\n    if (y < 0) {\n        ty -= y;\n        th += y;\n        h += y;\n        y = 0;\n    }\n    if (w > 0 && h > 0) {\n        context.drawImage(canvas, x, y, w, h, tx, ty, tw, th);\n    }\n}\n\n\n//# sourceURL=webpack://alttp/./app/utils/canvas.ts?");

/***/ }),

/***/ "./app/utils/dom.ts":
/*!**************************!*\
  !*** ./app/utils/dom.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bodyDiv: () => (/* binding */ bodyDiv),\n/* harmony export */   divider: () => (/* binding */ divider),\n/* harmony export */   findEmptyElement: () => (/* binding */ findEmptyElement),\n/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),\n/* harmony export */   getDomRectCenter: () => (/* binding */ getDomRectCenter),\n/* harmony export */   getElementIndex: () => (/* binding */ getElementIndex),\n/* harmony export */   getElementRect: () => (/* binding */ getElementRect),\n/* harmony export */   handleChildEvent: () => (/* binding */ handleChildEvent),\n/* harmony export */   mainContent: () => (/* binding */ mainContent),\n/* harmony export */   mouseContainer: () => (/* binding */ mouseContainer),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryAll: () => (/* binding */ queryAll),\n/* harmony export */   tag: () => (/* binding */ tag),\n/* harmony export */   tagElement: () => (/* binding */ tagElement),\n/* harmony export */   titleDiv: () => (/* binding */ titleDiv),\n/* harmony export */   toggleElement: () => (/* binding */ toggleElement),\n/* harmony export */   toggleElements: () => (/* binding */ toggleElements)\n/* harmony export */ });\nfunction query(className) {\n    return document.querySelector(className);\n}\nfunction queryAll(className) {\n    return document.querySelectorAll(className);\n}\nconst mouseContainer = query('.js-mouseContainer');\nconst mainContent = query('.js-gameContent');\nfunction tag(type, classes = '', content = '') {\n    return '<' + type + ' class=\"' + classes + '\">' + content + '</' + type + '>';\n}\nfunction tagElement(type, classes = '', content = '') {\n    const element = document.createElement(type);\n    element.className = classes || '';\n    element.innerHTML = '' + (content || '');\n    return element;\n}\nconst divider = tag('div', 'centered medium', tag('div', 'divider'));\nfunction titleDiv(titleMarkup) {\n    return titleMarkup && tag('div', 'title', titleMarkup);\n}\nfunction bodyDiv(bodyMarkup) {\n    return bodyMarkup && tag('div', 'body', bodyMarkup);\n}\n;\nfunction findEmptyElement(elements) {\n    return [...elements].find(element => element.innerHTML === '');\n}\nfunction getDomRectCenter(r) {\n    return [r.x + r.width / 2, r.y + r.height / 2];\n}\nfunction getElementRect(element, container) {\n    let b = element.getBoundingClientRect();\n    const rect = { x: b.left, y: b.top, w: b.width, h: b.height };\n    // If container is specified, return the rectangle relative to the container's coordinates.\n    if (container) {\n        const containerRect = container.getBoundingClientRect();\n        rect.x -= containerRect.left;\n        rect.y -= containerRect.top;\n    }\n    return rect;\n}\nfunction getClosestElement(element, elements, threshold) {\n    let closestElement = null;\n    let closestDistanceSquared = threshold * threshold;\n    const center = getDomRectCenter(element.getBoundingClientRect());\n    elements.forEach(element => {\n        const elementCenter = getDomRectCenter(element.getBoundingClientRect());\n        const d2 = (center[0] - elementCenter[0]) ** 2 + (center[1] - elementCenter[1]) ** 2;\n        if (d2 <= closestDistanceSquared) {\n            closestDistanceSquared = d2;\n            closestElement = element;\n        }\n    });\n    return closestElement;\n}\nfunction toggleElements(elements, show) {\n    elements.forEach(element => toggleElement(element, show));\n}\nfunction toggleElement(element, show) {\n    element.style.display = show ? '' : 'none';\n}\nfunction handleChildEvent(eventType, container, selector, handler) {\n    container.addEventListener(eventType, event => {\n        const element = event.target;\n        const matchedElement = element.closest(selector);\n        if (matchedElement) {\n            return handler(matchedElement, event);\n        }\n    });\n}\nfunction getElementIndex(element) {\n    if (!element.parentElement) {\n        return -1;\n    }\n    return [...element.parentElement.children].indexOf(element);\n}\n\n\n//# sourceURL=webpack://alttp/./app/utils/dom.ts?");

/***/ }),

/***/ "./app/utils/geometry.ts":
/*!*******************************!*\
  !*** ./app/utils/geometry.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doCirclesIntersect: () => (/* binding */ doCirclesIntersect),\n/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),\n/* harmony export */   getDistance: () => (/* binding */ getDistance),\n/* harmony export */   getTargetVector: () => (/* binding */ getTargetVector),\n/* harmony export */   isCircleInCircle: () => (/* binding */ isCircleInCircle),\n/* harmony export */   isPointInRect: () => (/* binding */ isPointInRect),\n/* harmony export */   turnTowardsAngle: () => (/* binding */ turnTowardsAngle)\n/* harmony export */ });\nfunction isPointInRect({ x, y, w, h }, p) {\n    return p.x >= x && p.x <= (x + w) && p.y >= y && p.y <= (y + h);\n}\nfunction getDistance(a, b) {\n    const dx = a.x - b.x, dy = a.y - b.y;\n    return (dx * dx + dy * dy) ** 0.5;\n}\nfunction doCirclesIntersect(circleA, circleB) {\n    const radius = circleA.radius + circleB.radius;\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\n    return dx * dx + dy * dy < radius * radius;\n}\nfunction isCircleInCircle(circleA, circleB) {\n    const radius = circleB.radius - circleA.radius;\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\n    return dx * dx + dy * dy < radius * radius;\n}\nfunction getClosestElement({ x, y }, elements) {\n    let closestDistance2 = Number.MAX_SAFE_INTEGER, closestElement = elements[0];\n    for (const element of elements) {\n        const dx = element.x - x, dy = element.y - y;\n        const distance2 = dx * dx + dy * dy - element.radius * element.radius;\n        if (distance2 < closestDistance2) {\n            closestDistance2 = distance2;\n            closestElement = element;\n        }\n    }\n    return closestElement;\n}\nfunction getTargetVector(pointA, pointB) {\n    const dx = pointB.x - pointA.x, dy = pointB.y - pointA.y;\n    const distance2 = dx * dx + dy * dy;\n    if (distance2 <= 0) {\n        return { x: 1, y: 0, distance2: 0 };\n    }\n    return { x: dx, y: dy, distance2 };\n}\nfunction turnTowardsAngle(theta, delta, targetTheta) {\n    const negativeDistance = (theta - targetTheta + 2 * Math.PI) % (2 * Math.PI);\n    const positiveDistance = (targetTheta - theta + 2 * Math.PI) % (2 * Math.PI);\n    if (negativeDistance <= delta || positiveDistance <= delta) {\n        return targetTheta;\n    }\n    if (negativeDistance < positiveDistance) {\n        return theta - delta;\n    }\n    return theta + delta;\n}\n\n\n//# sourceURL=webpack://alttp/./app/utils/geometry.ts?");

/***/ }),

/***/ "./app/utils/mouse.ts":
/*!****************************!*\
  !*** ./app/utils/mouse.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addContextMenuListeners: () => (/* binding */ addContextMenuListeners),\n/* harmony export */   bindMouseListeners: () => (/* binding */ bindMouseListeners),\n/* harmony export */   getMousePosition: () => (/* binding */ getMousePosition),\n/* harmony export */   isMiddleMouseDown: () => (/* binding */ isMiddleMouseDown),\n/* harmony export */   isMouseDown: () => (/* binding */ isMouseDown),\n/* harmony export */   isMouseOverElement: () => (/* binding */ isMouseOverElement),\n/* harmony export */   isRightMouseDown: () => (/* binding */ isRightMouseDown)\n/* harmony export */ });\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n//import { window.CANVAS_SCALE } from 'app/constants';\n\n\nlet mousePosition = [-1000, -1000];\nlet mouseIsDown = false;\nlet rightMouseIsDown = false;\nlet middleMouseIsDown = false;\nfunction isMouseDown() {\n    return mouseIsDown;\n}\nfunction getMousePosition(container = null, scale = 1) {\n    if (container) {\n        const containerRect = container.getBoundingClientRect();\n        return [\n            (mousePosition[0] - containerRect.x) / scale,\n            (mousePosition[1] - containerRect.y) / scale,\n        ];\n    }\n    return [mousePosition[0] / scale, mousePosition[1] / scale];\n}\nfunction onMouseMove(event) {\n    mousePosition = [event.pageX, event.pageY];\n    // console.log(mousePosition);\n}\nfunction onMouseDown(event) {\n    if (event.which === 1)\n        mouseIsDown = true;\n    if (event.which === 2)\n        middleMouseIsDown = true;\n    if (event.which === 3)\n        rightMouseIsDown = true;\n}\nfunction onMouseUp(event) {\n    if (event.which === 1)\n        mouseIsDown = false;\n    if (event.which === 2)\n        middleMouseIsDown = false;\n    if (event.which === 3)\n        rightMouseIsDown = false;\n}\nfunction bindMouseListeners() {\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mousedown', onMouseDown);\n    document.addEventListener('mouseup', onMouseUp);\n}\n/* This would in theory be used if we ever cleaned up the application\nexport function unbindMouseListeners() {\n    document.removeEventListener('mousemove', onMouseMove);\n    document.removeEventListener('mousedown', onMouseDown);\n    document.removeEventListener('mouseup', onMouseUp);\n    // Prevent mouse from being \"stuck down\"\n    mouseIsDown = false;\n}*/\nfunction isMouseOverElement(element) {\n    const rect = element.getBoundingClientRect();\n    return mousePosition[0] >= rect.x && mousePosition[0] <= rect.x + rect.width\n        && mousePosition[1] >= rect.y && mousePosition[1] <= rect.y + rect.height;\n}\nfunction isMiddleMouseDown() {\n    return middleMouseIsDown;\n}\nfunction isRightMouseDown() {\n    return rightMouseIsDown;\n}\nfunction addContextMenuListeners() {\n    // Prevent the context menu from displaying when clicking over the canvas unless shift is held.\n    app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__.mainCanvas.addEventListener('contextmenu', function (event) {\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.KEY.SHIFT)) {\n            return;\n        }\n        event.preventDefault();\n        // const [x, y] = getMousePosition();\n        // lastContextClick = getMousePosition(mainCanvas, window.CANVAS_SCALE);\n    });\n}\n\n\n//# sourceURL=webpack://alttp/./app/utils/mouse.ts?");

/***/ }),

/***/ "./app/utils/userInput.ts":
/*!********************************!*\
  !*** ./app/utils/userInput.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ANALOG_THRESHOLD: () => (/* binding */ ANALOG_THRESHOLD),\n/* harmony export */   KEY: () => (/* binding */ KEY),\n/* harmony export */   addKeyboardListeners: () => (/* binding */ addKeyboardListeners),\n/* harmony export */   clearKeyboardState: () => (/* binding */ clearKeyboardState),\n/* harmony export */   getMovementDeltas: () => (/* binding */ getMovementDeltas),\n/* harmony export */   getRightAnalogDeltas: () => (/* binding */ getRightAnalogDeltas),\n/* harmony export */   isGameKeyDown: () => (/* binding */ isGameKeyDown),\n/* harmony export */   isKeyboardKeyDown: () => (/* binding */ isKeyboardKeyDown),\n/* harmony export */   updateKeyboardState: () => (/* binding */ updateKeyboardState),\n/* harmony export */   wasGameKeyPressed: () => (/* binding */ wasGameKeyPressed),\n/* harmony export */   wasGameKeyPressedAndReleased: () => (/* binding */ wasGameKeyPressedAndReleased)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* global navigator */\n\nconst KEY = {\n    ESCAPE: 27,\n    LEFT: 37,\n    RIGHT: 39,\n    UP: 38,\n    DOWN: 40,\n    SPACE: 32,\n    SHIFT: 16,\n    ENTER: 13,\n    BACK_SPACE: 8,\n    COMMAND: 91,\n    CONTROL: 17,\n    LEFT_BRACKET: 219,\n    BACK_SLASH: 220,\n    RIGHT_BRACKET: 221,\n    A: 'A'.charCodeAt(0),\n    B: 'B'.charCodeAt(0),\n    C: 'C'.charCodeAt(0),\n    D: 'D'.charCodeAt(0),\n    E: 'E'.charCodeAt(0),\n    F: 'F'.charCodeAt(0),\n    G: 'G'.charCodeAt(0),\n    H: 'H'.charCodeAt(0),\n    I: 'I'.charCodeAt(0),\n    J: 'J'.charCodeAt(0),\n    K: 'K'.charCodeAt(0),\n    L: 'L'.charCodeAt(0),\n    M: 'M'.charCodeAt(0),\n    O: 'O'.charCodeAt(0),\n    P: 'P'.charCodeAt(0),\n    Q: 'Q'.charCodeAt(0),\n    R: 'R'.charCodeAt(0),\n    S: 'S'.charCodeAt(0),\n    T: 'T'.charCodeAt(0),\n    U: 'U'.charCodeAt(0),\n    V: 'V'.charCodeAt(0),\n    W: 'W'.charCodeAt(0),\n    X: 'X'.charCodeAt(0),\n    Y: 'Y'.charCodeAt(0),\n    Z: 'Z'.charCodeAt(0),\n};\nconst KEYBOARD_MAPPINGS = {\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MENU]: [KEY.ENTER],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: [KEY.UP, KEY.W],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: [KEY.DOWN, KEY.S],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: [KEY.LEFT, KEY.A],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: [KEY.RIGHT, KEY.D],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE]: [KEY.F],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL]: [KEY.X],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SHOOT]: [KEY.SPACE],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MUTE]: [KEY.M],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.GUARD_SKILL]: [KEY.SHIFT, KEY.C, KEY.V, KEY.B],\n};\n// Under this threshold, the analog buttons are considered \"released\" for the sake of\n// actions that are only taken once per button push (like moving a menu cursor).\nconst ANALOG_THRESHOLD = 0.3;\n// This mapping assumes a canonical gamepad setup as seen in:\n// https://w3c.github.io/gamepad/#remapping\n// Which seems to work well with my xbox 360 controller.\n// I based this code on examples from:\n// https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API\n// Easy to find mappings at: http://html5gamepad.com/\nconst GAME_PAD_MAPPINGS = {\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MENU]: 9,\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: 12,\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: 13,\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: 14,\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: 15,\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE]: [\n        0,\n        1, // B (right button)\n    ],\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL]: 3,\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.POTION]: 4,\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SHOOT]: 5,\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SPECIAL_ATTACK]: 6, // L Back Bumper\n    // 2, // X (left button)\n    // 7, // R Back bumper\n    // 8, // BACK\n    // 10 ??\n    // 11 ??\n};\nconst LEFT_ANALOG_Y_AXIS = 1;\nconst LEFT_ANALOG_X_AXIS = 0;\nconst RIGHT_ANALOG_Y_AXIS = 3;\nconst RIGHT_ANALOG_X_AXIS = 2;\n// These two are currently unused, but would be used for aiming instead of the mouse.\n//const RIGHT_ANALOG_Y_AXIS = 3; // eslint-disable-line no-unused-vars\n//const RIGHT_ANALOG_X_AXIS = 2; // eslint-disable-line no-unused-vars\nconst GAME_PAD_AXIS_MAPPINGS = {\n    // Map the negative y axis of the left stick to the up key.\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: [LEFT_ANALOG_Y_AXIS, -1],\n    // Map the positive y axis of the left stick to the down key.\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: [LEFT_ANALOG_Y_AXIS, 1],\n    // Map the negative x axis of the left stick to the up key.\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: [LEFT_ANALOG_X_AXIS, -1],\n    // Map the positive x axis of the left stick to the down key.\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: [LEFT_ANALOG_X_AXIS, 1],\n    // Map the negative y axis of the right stick to the aim up key.\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_UP]: [RIGHT_ANALOG_Y_AXIS, -1],\n    // Map the positive y axis of the right stick to the aim down key.\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_DOWN]: [RIGHT_ANALOG_Y_AXIS, 1],\n    // Map the negative x axis of the right stick to the aim up key.\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_LEFT]: [RIGHT_ANALOG_X_AXIS, -1],\n    // Map the positive x axis of the right stick to the aim down key.\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_RIGHT]: [RIGHT_ANALOG_X_AXIS, 1],\n};\n// Apparently, depending on the button type, either button.pressed or button == 1.0 indicates the button is pressed.\nfunction buttonIsPressed(button) {\n    if (typeof (button) == \"object\")\n        return button.pressed;\n    return button == 1.0;\n}\nconst keysDown = [];\nlet lastInput;\nfunction isKeyboardKeyDown(keyCode) {\n    if (keysDown[keyCode]) {\n        lastInput = 'keyboard';\n        return 1;\n    }\n    return 0;\n}\nfunction isGamepadGamekeyPressed(gameKey) {\n    // If a mapping exists for the current key code to a gamepad button,\n    // check if that gamepad button is pressed.\n    const buttonIndexArrayOrNumber = GAME_PAD_MAPPINGS[gameKey], axisIndex = GAME_PAD_AXIS_MAPPINGS[gameKey];\n    const buttonIndexArray = Array.isArray(buttonIndexArrayOrNumber) ? buttonIndexArrayOrNumber : [buttonIndexArrayOrNumber];\n    for (const buttonIndex of buttonIndexArray) {\n        if (typeof (buttonIndex) !== 'undefined' || typeof (axisIndex) !== 'undefined') {\n            // There can be multiple game pads connected. For now, let's just check all of them for the button.\n            const gamepads = navigator.getGamepads();\n            for (const gamepad of gamepads) {\n                if (!gamepad)\n                    continue;\n                let value = 0;\n                if (typeof (buttonIndex) !== 'undefined' && buttonIsPressed(gamepad.buttons[buttonIndex])) {\n                    value = 1;\n                }\n                else if (typeof (axisIndex) !== 'undefined' && gamepad.axes[axisIndex[0]] * axisIndex[1] > 0) {\n                    value = gamepad.axes[axisIndex[0]] * axisIndex[1];\n                }\n                if (value) {\n                    if (value >= ANALOG_THRESHOLD) {\n                        lastInput = 'gamepad';\n                    }\n                    return value;\n                }\n            }\n        }\n    }\n    return 0;\n}\nfunction addKeyboardListeners() {\n    addEventListener('blur', (event) => {\n        for (let i = 0; i < keysDown.length; i++) {\n            keysDown[i] = 0;\n        }\n    });\n    document.addEventListener('keyup', function (event) {\n        const keyCode = event.which;\n        keysDown[keyCode] = 0;\n    });\n    document.addEventListener('keydown', function (event) {\n        if (event.repeat) {\n            return;\n        }\n        // Don't process keys if an input is targeted, otherwise we prevent typing in\n        // the input.\n        if (event.target.closest('input')\n            || event.target.closest('textarea')\n            || event.target.closest('select')) {\n            return;\n        }\n        const commandIsDown = (keysDown[KEY.CONTROL] || keysDown[KEY.COMMAND]);\n        const keyCode = event.which;\n        //console.log(keyCode);\n        // Don't override the refresh page command.\n        if (keyCode === KEY.R && commandIsDown) {\n            return;\n        }\n        keysDown[keyCode] = 1;\n    });\n}\nfunction updateKeyboardState(state) {\n    const previousGameKeysDown = state.keyboard.gameKeysDown;\n    // This set is persisted until a new set of keys is pressed.\n    let mostRecentKeysPressed = state.keyboard.mostRecentKeysPressed;\n    const gameKeyValues = [];\n    const gameKeysDown = new Set();\n    const gameKeysPressed = new Set();\n    const gameKeysReleased = new Set();\n    /*for (const gameKey of GAME_PAD_AXIS_MAPPINGS) {\n\n    }*/\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\n        gameKeyValues[gameKey] = 0;\n        for (const keyboardCode of (KEYBOARD_MAPPINGS[gameKey] || [])) {\n            gameKeyValues[gameKey] = isKeyboardKeyDown(keyboardCode);\n            if (gameKeyValues[gameKey]) {\n                break;\n            }\n        }\n        if (!gameKeyValues[gameKey]) {\n            gameKeyValues[gameKey] = isGamepadGamekeyPressed(gameKey);\n        }\n        if (gameKeyValues[gameKey] >= ANALOG_THRESHOLD) {\n            gameKeysDown.add(gameKey);\n        }\n    }\n    for (const oldKeyDown of [...previousGameKeysDown]) {\n        if (!gameKeysDown.has(oldKeyDown)) {\n            gameKeysReleased.add(oldKeyDown);\n        }\n    }\n    for (const newKeyDown of [...gameKeysDown]) {\n        if (!previousGameKeysDown.has(newKeyDown)) {\n            gameKeysPressed.add(newKeyDown);\n        }\n    }\n    if (gameKeysPressed.size > 0) {\n        mostRecentKeysPressed = gameKeysPressed;\n    }\n    state.keyboard = { gameKeyValues, gameKeysDown, gameKeysPressed, gameKeysReleased, mostRecentKeysPressed };\n    if (lastInput === 'gamepad') {\n        state.isUsingKeyboard = false;\n        state.isUsingXbox = true;\n    }\n    else if (lastInput === 'keyboard') {\n        state.isUsingKeyboard = true;\n        state.isUsingXbox = false;\n    }\n}\nfunction clearKeyboardState(state) {\n    const gameKeyValues = [];\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\n        gameKeyValues[gameKey] = 0;\n    }\n    state.keyboard = {\n        gameKeyValues,\n        gameKeysDown: new Set(),\n        gameKeysPressed: new Set(),\n        gameKeysReleased: new Set(),\n        mostRecentKeysPressed: new Set(),\n    };\n}\nfunction wasGameKeyPressed(state, keyCode) {\n    return state.keyboard.gameKeysPressed.has(keyCode);\n}\n// Only returns true if a key was pressed and released without any other keys having been pressed in between.\n// Specifically this is used to determined whether to switch clones, which should only happen if the user presses\n// the clone tool button without pressing any other buttons before releasing it. Note that it is okay if they\n// continue holding buttons that were already down when pressing the clone button.\nfunction wasGameKeyPressedAndReleased(state, keyCode) {\n    return state.keyboard.mostRecentKeysPressed.has(keyCode) && state.keyboard.gameKeysReleased.has(keyCode);\n}\nfunction isGameKeyDown(state, keyCode) {\n    return state.keyboard.gameKeysDown.has(keyCode);\n}\nfunction getMovementDeltas(state) {\n    const { gameKeyValues } = state.keyboard;\n    let dy = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP];\n    if (Math.abs(dy) < ANALOG_THRESHOLD)\n        dy = 0;\n    let dx = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT];\n    if (Math.abs(dx) < ANALOG_THRESHOLD)\n        dx = 0;\n    if (isNaN(dx) || isNaN(dy)) {\n        debugger;\n    }\n    return [dx, dy];\n}\nfunction getRightAnalogDeltas(state) {\n    const { gameKeyValues } = state.keyboard;\n    let dy = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_DOWN] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_UP];\n    let dx = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_RIGHT] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_LEFT];\n    if (Math.abs(dx) < ANALOG_THRESHOLD && Math.abs(dy) < ANALOG_THRESHOLD) {\n        return [0, 0];\n    }\n    if (isNaN(dx) || isNaN(dy)) {\n        debugger;\n    }\n    return [dx, dy];\n}\n\n\n//# sourceURL=webpack://alttp/./app/utils/userInput.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/client.ts");
/******/ 	
/******/ })()
;